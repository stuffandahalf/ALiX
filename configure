#!/bin/sh

#  Copyright (c) 2022 Gregory Norton <gregory.norton@me.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#

# This script reads a list of variables from a configuration file
# and produces a posix compliant makefile

# functions to simplify makefile generation
usage() {
	printf "usage: %s [-A architecture] [-B build dir] [-F kernel format] [-v+] [-h]\n" $1
}

log() {
	if [ $VERBOSE -ge $1 ]; then
		shift 1
		echo "$@" >&2
	fi
}

emit() {
	printf "$@"  >> "$DIR$OUT_MAKEFILE"
}

path_dirs() {
	if [ "$1" ]; then
		PATHS="$1"
	else
		PATHS="$PATH"
	fi
	echo "$PATHS" | sed -e "s/:/\n/g"
}

src2obj() {
	for SRC in $@; do
		printf "$SRC" | sed -e "s/\..*$/\.o /"
	done
}

staticlib_fname() {
	for LIB in $@; do
		printf "lib$LIB.a "
	done
}

dynlib_fname() {
	for LIB in $@; do
		printf "lib$LIB.so "
	done
}

ldargs() {
	for LIB in $@; do
		printf "-"
		printf "l $LIB "
	done
	printf "\n"
}

emit_target_deps() {
	for SOURCE in $@; do
		emit "`src2obj $SOURCE`: $SOURCE\n"
		emit "\t\"${CC}\" ${CFLAGS} ${TARGET_CFLAGS} -c -o `src2obj $SOURCE` $SOURCE\n"
		emit "\n"
	done
}

test_file_arch() {
	for ARCH in $ALTNAMES; do
		if file "$1" | grep -i "$ARCH" > /dev/null; then
			return 0
		fi
	done
	return 1
}

var_name() {
	for F in $@; do
		echo "$F" | sed -e "s/[^a-zA-Z0-9_]/_/"
	done
}

# Build Variables
IN_MAKEFILE=make.conf
IN_PREDEF_MAKEFILE=make.predef.conf
OUT_MAKEFILE=makefile
REQUIRED_C_STANDARD=1
export REQUIRED_C_STANDARD

SUPPORTED_ARCHS="i386 amd64 ppc ppc64 arm32 aarch64 riscv32 riscv64"
i386_ALTNAMES="i386 i486 i586 i686 i86pc 80386 80486 80586 80686"
amd64_ALTNAMES="amd64 x86_64 x86-64"
ppc_ALTNAMES="ppc powerpc"
ppc64_ALTNAMES="ppc64 powerpc"
arm32_ALTNAMES="arm32 arm armv6"
aarch64_ALTNAMES="aarch64 arm64"
riscv32_ALTNAMES="riscv32 risc-v riscv risc-v32"
riscv64_ALTNAMES="riscv64 risc-v64"

i386_COMPATIBLE_TOOLCHAINS=amd64
ppc_COMPATIBLE_TOOLCHAINS=ppc64

if [ -z "$CONFIGURED" ]; then
	TARGET_ARCH=`uname -m`
	export TARGET_ARCH
	VERBOSE=0
	export VERBOSE
	BUILD_PREFIX=""
	export BUILD_PREFIX
	KERNEL_FORMAT=""
	export KERNEL_FORMAT

	while getopts 'A:B:F:vh' opt; do
		case $opt in
			(A)
				ARCH_ARG=$OPTARG
				TARGET_ARCH=
				;;
			(B) BUILD_DIR=$OPTARG;;
			(F) KERNEL_FORMAT=$OPTARG;;
			(v) VERBOSE=`dc -e "$VERBOSE 1 + p"`;;
			(h) usage "$0"; exit 1;;
			(?) usage "$0" >&2; exit 1;;
		esac
	done

	# check that selected arch is legal and set preferred name
	for ARCH in $SUPPORTED_ARCHS; do
		eval "ALTNAMES=\$${ARCH}_ALTNAMES"
		for ALTNAME in $ALTNAMES; do
			if [ "$ARCH_ARG" = "$ALTNAME" ]; then
				TARGET_ARCH="$ARCH"
			fi
		done
	done
	if [ -z "$TARGET_ARCH" ]; then
		log 0 "Unsupported architecture \"$ARCH_ARG\""
		exit 1
	fi
	log 0 "TARGETING $TARGET_ARCH"

	CONFIGURED=1
	export CONFIGURED
fi
shift `dc -e "$OPTIND 1 - p"`

# set up tool paths and names to search for
CC_CANDIDATES="c99 cc clang gcc"
LD_CANDIDATES="ld bfd lld ld.lld gold ld.gold mold ld.mold"
AR_CANDIDATES="ar llvm-ar gcc-ar"
eval "TOOLCHAIN_ARCHS=\"\$${TARGET_ARCH}_ALTNAMES\""
eval "COMPATIBLE_TOOLCHAINS=\"\$${TARGET_ARCH}_COMPATIBLE_TOOLCHAINS\""
for TC_COMPAT in $COMPATIBLE_TOOLCHAINS; do
	eval "ALTNAMES=\"\$${TC_COMPAT}_ALTNAMES\""
	for ALTNAME in $ALTNAMES; do
		TOOLCHAIN_ARCHS="$TOOLCHAIN_ARCHS $ALTNAME"
	done
done
for TC_ARCH in $TOOLCHAIN_ARCHS; do
	CC_CANDIDATES="$CC_CANDIDATES $TC_ARCH-elf-gcc $TC_ARCH-elf-none-gcc $TC_ARCH-elf-alix-gcc"
	LD_CANDIDATES="$LD_CANDIDATES $TC_ARCH-elf-ld $TC_ARCH-elf-none-ld $TC_ARCH-elf-alix-ld $TC_ARCH-elf-ld.bfd $TC_ARCH-elf-none-ld.bfd $TC_ARCH-elf-alix-ld.bfd"
	AR_CANDIDATES="$AR_CANDIDATES $TC_ARCH-elf-ar $TC_ARCH-elf-none-ar $TC_ARCH-elf-alix-ar"
done

# determine CC
if [ -z "$CC_FOUND" ]; then
	if [ "$CC" ]; then
		CC_CANDIDATES="`basename \`which "$CC"\``"
		CC_CANDIDATE_PATHS="`dirname \`which "$CC"\``"
	else
		CC_CANDIDATE_PATHS="$PATHS"
	fi
	FOUND=""
	for DIR in `path_dirs "$CC_CANDIDATE_PATHS"`; do
		if [ ! -z "$FOUND" ]; then
			break
		fi

		log 2 "CHECKING \"$DIR\" for CC candidates"
		for CANDIDATE in $CC_CANDIDATES; do
			CC="$DIR/$CANDIDATE"
			CFLAGS_TEST="$CFLAGS"
			if [ ! -x "$CC" ]; then
				continue
			fi
			log 1 "TESTING \"$CC\""

			# Check brand of C compiler
			log 1 "C compiler brand..."
			if "$CC" $CFLAGS_TEST -v 2>&1 | grep -i "clang" > /dev/null; then
				CC_BRAND=clang
			elif "$CC" $CFLAGS_TEST -v 2>&1 | grep -i "gcc" > /dev/null; then
				CC_BRAND=gcc
			elif [ `basename "$CC"` = "c99" ]; then
				CC_BRAND=posix
			fi
			log 1 "$CC_BRAND"

			# check if compiler automatically imports headers
			log 1 "Checking if C compiler provides stdlib headers..."
			printf "#include <stdio.h>\n" > .stdinc.c
			"$CC" $CFLAGS_TEST -c .stdinc.c 2> /dev/null
			TMP=$?
			if [ $TMP -eq 0 ]; then
				case "$CC_BRAND" in
					gcc)
						CFLAGS_TEST="-nostdinc -ffreestanding $CFLAGS_TEST"
						;;
					clang)
						CFLAGS_TEST="-nostdinc -ffreestanding $CFLAGS_TEST"
						;;
					# otherwise, default headers imported, but should be avoided if possible
					#*)
					#	log 1 "FAILED"
					#	break
					#	;;
				esac
			fi
			rm -f .stdinc.c .stdinc.o
			log 1 "OK"

			# check default target of compiler
			#log 1 "Default C compiler target..."
			#CC_TARGET=`"$CC" $CFLAGS_TEST -v 2>&1 | grep -i "^target" | cut -d' ' -f2 | cut -d'-' -f1`
			#if [ $? -ne 0 ]; then
			#	log 1 "FAILED"
			#	break
			#fi
			#log 1 "$CC_TARGET"

			# verify if compiler target matches requested target
			# if not, attempt to set CFLAGS to change target

			# Test for ELF output fomat
			log 1 "Executable format test..."
			printf "int main(int argc,char **argv){return 0;}\n" > .filefmt.c
			"$CC" $CFLAGS_TEST -c .filefmt.c
			EXPECTED_ELF_MAGIC=`printf '\177ELF'`
			ACTUAL_ELF_MAGIC=`head -c 4 .filefmt.o`
			if [ "$EXPECTED_ELF_MAGIC" != "$ACTUAL_ELF_MAGIC" ]; then
				if [ "$CC_BRAND" = "clang" ] && "$CC" --target=$TARGET_ARCH-none-elf $CFLAGS_TEST -c .filefmt.c; then
					ACTUAL_ELF_MAGIC=`head -c 4 .filefmt.o`
					if [ "$EXPECTED_ELF_MAGIC" != "$ACTUAL_ELF_MAGIC" ]; then
						rm -f .filefmt.c .filefmt.o
						log 1 "FAILED"
						continue
					fi
				else
					rm -f .filefmt.c .filefmt.o
					log 1 "FAILED"
					continue
				fi
			fi
			log 1 "OK"

			log 1 "Output file architecture test..."
			CC_OUTPUT_COMPATIBLE=0
			eval "ALTNAMES=\"\${${TARGET_ARCH}_ALTNAMES}\""
			test_file_arch .filefmt.o
			CC_OUTPUT_COMPATIBLE=$?

			if [ $CC_OUTPUT_COMPATIBLE -ne 0 ]; then
				if "$CC" -m32 $CFLAGS_TEST -c .filefmt.c && test_file_arch .filefmt.o; then
					CC_OUTPUT_COMPATIBLE=0
					if [ $CC_OUTPUT_COMPATIBLE -eq 0 ]; then
						CFLAGS_TEST="-m32 $CFLAGS_TEST"
					fi
				elif [ "$CC_BRAND" == "clang" ] && \
						"$CC" --target=$TARGET_ARCH-none-elf $CFLAGS_TEST -c .filefmt.c && \
						test_file_arch .filefmt.o; then
					CC_OUTPUT_COMPATIBLE=0
					if [ $CC_OUTPUT_COMPATIBLE -eq 0 ]; then
						CFLAGS_TEST="--target=$TARGET_ARCH-none-elf $CFLAGS_TEST"
					fi
				fi
			fi

			rm -f .filefmt.c .filefmt.o
			if [ $CC_OUTPUT_COMPATIBLE -ne 0 ]; then
				log 1 "FAILED"
				continue
			fi
			log 1 "OK"

			# Test C standard
			log 1 "Standard C test..."
			printf "#if !defined(__STDC__)\n0\n#elif defined(__STDC_VERSION__)\n__STDC_VERSION__\n#else\n1\n#endif\n" > .std.c
			CC_STD=`"$CC" $CFLAGS_TEST -E .std.c | grep '^[0-9]' | sed -e 's/L$//'`
			rm -f .std.c
			if [ "$CC_STD" -lt "$REQUIRED_C_STANDARD" ]; then
				log 1 "FAILED"
				break
			fi
			log 1 "OK ($CC_STD)"

			log 1 "PASSED $CC"

			CFLAGS="$CFLAGS_TEST"
			FOUND="yes"
			break
		done
	done

	if [ -z "$FOUND" ]; then
		log 0 "Failed to locate compatible CC"
		exit 1
	fi

	CC_FOUND=1
	export CC_FOUND
	export CC
	export CFLAGS
fi

# determine LD
if [ -z "$LD_FOUND" ]; then
	if [ $LD ]; then
		LD_CANDIDATES="`basename \`which "$LD"\``"
		LD_PATHS="`dirname \`which $LD\``"
	else
		LD_PATHS="$PATHS"
	fi
	FOUND=""

	for DIR in `path_dirs $LD_PATHS`; do
		if [ ! -z "$FOUND" ]; then
			break
		fi

		log 2 "CHECKING \"$DIR\" for LD candidates"

		for CANDIDATE in $LD_CANDIDATES; do
			LD="$DIR/$CANDIDATE"
			LDFLAGS_TEST="$LDFLAGS"

			if [ ! -x $LD ]; then
				continue
			fi

			log 1 "TESTING \"$LD\""

			# run tests
			echo "void _start(void) { }" > .entry.c
			echo "extern int puts(const char *); int main(int argc, char **argv) {puts(\"Hello World!\");return 0;}" > .main.c

			#"$CC" $CFLAGS -c .entry.c
			#"$CC" $CFLAGS -c .main.c
			#log 2 "Attempting clean link"
			#"$LD" $LDFLAGS_TEST -o .entry .entry.o 2> /dev/null
			#file .entry
			#CLEAN_LINK=$?
			#if [ $CLEAN_LINK -ne 0 ]; then
				#log 2 "FAILED"
			#else
				#log 2 "OK"
			#fi

			"$CC" -c .entry.c
			"$CC" -c .main.c
			log 2 "Attempt to link user space application"
			if "$LD" "$LDFLAGS_TEST" -o .main .main.o 2> /dev/null; then
				log 2 "OK"
				USERSPACE_LINKER=0
			else
				log 2 "FAILED"
				USERSPACE_LINKER=1
			fi

			"$CC" $CFLAGS -c .entry.c
			"$CC" $CFLAGS -c .main.c

			log 2 "Attempt to link using arch flags"
			if [ $USERSPACE_LINKER -eq 0 ]; then
				if "$LD" -m32 $LDFLAGS_TEST -o .main .main.o 2> /dev/null; then
					LDFLAGS_TEST="-m32 $LDFLAGS_TEST"
					log 2 "OK"
				elif "$LD" -target=${TARGET_ARCH}-none-elf $LDFLAGS_TEST -o .main .main.o 2> /dev/null; then
					LDFLAGS_TEST="-target=${TARGET_ARCH}-none-elf $LDFLAGS_TEST"
					log 2 "OK"
				else
					eval "ALTNAMES=\$${TARGET_ARCH}_ALTNAMES"
					COMPATIBLE_ALTNAME=1
					for ALTNAME in $ALTNAMES; do
						if "$LD" -melf_${ALTNAME} $LDFLAGS_TEST -o .main .main.o 2> /dev/null; then
							LDFLAGS_TEST="-melf_${ALTNAME} $LDFLAGS_TEST"
							log 2 "OK"
							COMPATIBLE_ALTNAME=0
							break
						fi
					done
					if [ "$COMPATIBLE_ALTNAME" -eq 1 ]; then
						log 2 "FAILED"
						rm -f .entry.c .entry.o .entry .main.c .main.o .main
						continue
					fi
				fi
			else
				if "$LD" -m32 $LDFLAGS_TEST -o .entry .entry.o 2> /dev/null; then
					LDFLAGS_TEST="-m32 $LDFLAGS_TEST"
					log 2 "OK"
				elif "$LD" -target=${TARGET_ARCH}-none-elf $LDFLAGS_TEST -o .entry .entry.o 2> /dev/null; then
					LDFLAGS_TEST="-target=${TARGET_ARCH}-none-elf $LDFLAGS_TEST"
					log 2 "OK"
				else
					eval "ALTNAMES=\$${TARGET_ARCH}_ALTNAMES"
					COMPATIBLE_ALTNAME=1
					for ALTNAME in $ALTNAMES; do
						if "$LD" -melf_${ALTNAME} $LDFLAGS_TEST -o .entry .entry.o 2> /dev/null; then
							LDFLAGS_TEST="-melf_${ALTNAME} $LDFLAGS_TEST"
							log 2 "OK"
							COMPATIBLE_ALTNAME=0
							break
						fi
					done
					if [ "$COMPATIBLE_ALTNAME" -eq 1 ]; then
						log 2 "FAILED"
						rm -f .entry.c .entry.o .entry .main.c .main.o .main
						continue
					fi
				fi
			fi

			if [ $USERSPACE_LINKER -eq 0 ]; then
				log 2 "Attempt to use userspace linker to link freestanding binary"
				if "$LD" -nostdlib $LDFLAGS_TEST -o .entry .entry.o; then
					LDFLAGS_TEST="-nostdlib $LDFLAGS_TEST"
					log 2 "OK"
				else
					log 2 "FAILED"
					rm -f .entry.c .entry.o .entry .main.c .main.o .main
					continue
				fi
			fi
			rm -f .entry.c .entry.o .entry .main.c .main.o .main

			LDFLAGS="$LDFLAGS_TEST"
			FOUND="yes"
			break
		done
	done

	if [ -z "$FOUND" ]; then
		log 0 "Failed to locate compatible LD"
		exit 1
	fi

	LD_FOUND=1
	export LD_FOUND
	export LD
	export LDFLAGS
fi

# determine AR
if [ -z "$AR_FOUND" ]; then
	if [ "$AR" ]; then
		AR_CANDIDATES="`basename \`which "$AR"\``"
		AR_PATHS="`dirname \`which "$AR"\``"
	else
		AR_PATHS="$PATHS"
	fi
	FOUND=""

	for DIR in `path_dirs "$AR_PATHS"`; do
		if [ ! -z "$FOUND" ]; then
			break
		fi

		log 2 "CHECKING \"$DIR\" for AR candidates"

		for CANDIDATE in $AR_CANDIDATES; do
			AR="$DIR/$CANDIDATE"
			ARFLAGS_TEST="$ARFLAGS -rvs"

			if [ ! -x "$AR" ]; then
				continue
			fi

			log 1 "TESTING \"$AR\""

			# run tests
			log 1 "Linking ELF library..."
			echo "void test(void) {}" > .artest.c
			echo "void _start(void) {}" > .driver.c
			"$CC" $CFLAGS -c -o .artest.o .artest.c
			"$AR" $ARFLAGS_TEST libtest.a .artest.o 2> /dev/null > /dev/null
			if [ $? -ne 0 ]; then
				rm -f .artest.c .driver.c .artest.o libtest.a
				log 1 "Failed"
				continue
			fi
			"$CC" $CFLAGS -c -o .driver.o .driver.c
			"$LD" $LDFLAGS -L. -o .test .driver.o -ltest
			TMP=$?
			rm -f .artest.c .driver.c .artest.o .driver.o libtest.a .test
			if [ $TMP -ne 0 ]; then
				log 1 "Failed"
				continue
			fi
			log 1 "OK"

			ARFLAGS="$ARFLAGS_TEST"
			FOUND="yes"
			break
		done
	done

	if [ -z "$FOUND" ]; then
		log 0 "Failed to locate compatible AR"
		exit 1
	fi

	AR_FOUND=1
	export AR_FOUND
	export AR
	export ARFLAGS
fi

# Determine current directory
DIR="$PWD/"
if [ $# -gt 0 ]; then
	DIR="$1"
fi
export DIR

# import any configuration that should be applied to subdirectories
if [ -f $DIR/$IN_PREDEF_MAKEFILE ]; then
	. "$DIR/$IN_PREDEF_MAKEFILE"
fi

# Lookup subdirectories
SUBDIRS=`ls -d "$DIR"*/ 2> /dev/null`
# Recurse through subdirectories and configure them
if [ $? -eq 0 ]; then
	for SUBDIR in $SUBDIRS; do
		log 2 "ENTERING $SUBDIR"
		$0 "$SUBDIR"
		log 2 "LEAVING $SUBDIR"
	done
fi
SUBDIRS=

set -e

# look for makefile configuration file

if [ -f "$DIR/$OUT_MAKEFILE" ]; then
	if [ ! -f "$DIR/$IN_MAKEFILE" ]; then
		exit 0
	elif [ "$DIR/$IN_MAKEFILE" -ot "$DIR/$OUT_MAKEFILE" ]; then
		exit 0
	fi
elif [ ! -f "$DIR/$IN_MAKEFILE" ]; then
	exit 1
fi

# Import directory make variables as shell variables
. "$DIR/$IN_MAKEFILE"

SUBDIR_TARGETS=
for SUBDIR in $SUBDIRS; do
	SUBDIR_TARGETS="$SUBDIR.dir $SUBDIR_TARGETS"
done

log 0 "CREATING $DIR$OUT_MAKEFILE"

# create output file
if [ -e "$DIR$OUT_MAKEFILE" ]; then
	rm -f "$DIR$OUT_MAKEFILE"
fi
touch "$DIR$OUT_MAKEFILE"
BUILD_ARTIFACTS=



# write output file
emit ".POSIX:\n"
emit "\n"
emit "all: subdirs $TARGETS `staticlib_fname $STATIC_LIB_TARGETS` `dynlib_fname $DYNAMIC_LIB_TARGETS`\n"
emit "\n"
emit "subdirs: $SUBDIR_TARGETS"
emit "\n\n"
for SUBDIR in $SUBDIRS; do
	emit "$SUBDIR.dir: $SUBDIR\n"
	emit "\tcd \"$SUBDIR\" && \$(MAKE) all\n"
	emit "\n"
done
for TARGET in $TARGETS; do
	# evaluate target variables
	TARGET_VAR=`var_name $TARGET`
	eval "TARGET_EXTRA_DEPS=\${${TARGET_VAR}_EXTRA_DEPENDENCIES}"
	eval "TARGET_SOURCES=\${${TARGET_VAR}_SOURCES}"
	eval "TARGET_CFLAGS=\${${TARGET_VAR}_CFLAGS}"
	eval "TARGET_LDFLAGS=\${${TARGET_VAR}_LDFLAGS}"
	eval "TARGET_LIBS=\${${TARGET_VAR}_LIBS}"
	eval "LIB_LOOKUP_DIRS=\${${TARGET_VAR}_LIB_LOOKUP_DIRS}"
	OBJECTS="`src2obj $TARGET_SOURCES`"
	#BUILD_SOURCES="$BUILD_SOURCES $TARGET_SOURCES"
	BUILD_ARTIFACTS="$BUILD_ARTIFACTS $OBJECTS"

	emit "$TARGET: subdirs $TARGET_LIBS $OBJECTS $TARGET_EXTRA_DEPS\n"
	emit "\t\"${LD}\" $LDFLAGS $TARGET_LDFLAGS"
	for LIB_LOOKUP_DIR in $LIB_LOOKUP_DIRS; do
		emit " -L$LIB_LOOKUP_DIR"
	done
	emit " -o$TARGET $OBJECTS"
	for LIB in $TARGET_LIBS; do
		emit " -l$LIB"
	done
	emit "\n\n"
	emit_target_deps $TARGET_SOURCES
done
for STATIC_LIB in $STATIC_LIB_TARGETS; do
	# evaluate library variables
	TARGET_VAR=`var_name "$STATIC_LIB"`
	eval "TARGET_SOURCES=\${${TARGET_VAR}_SOURCES}"
	eval "TARGET_CFLAGS=\${${TARGET_VAR}_CFLAGS}"
	eval "TARGET_ARFLAGS=\${${TARGET_VAR}_ARFLAGS}"
	OBJECTS="`src2obj $TARGET_SOURCES`"
	BUILD_ARTIFACTS="$BUILD_ARTIFACTS $OBJECTS"

	# TODO: emit target linking
	emit "`staticlib_fname $STATIC_LIB`: subdirs $OBJECTS $EXTRA_DEPS\n"
	emit "\t\"${AR}\" ${ARFLAGS} ${TARGET_ARFLAGS} `staticlib_fname \"$STATIC_LIB\"` $OBJECTS\n"
	emit "\n"
	emit_target_deps $TARGET_SOURCES
done
for DYNAMIC_LIB in $DYNAMIC_LIB_TARGETS; do
	# evaluate library variables
	TARGET_VAR=`var_name "$DYNAMIC_LIB"`
	eval "TARGET_SOURCES=\${${TARGET_VAR}_SOURCES}"
	eval "TARGET_CFLAGS=\${${TARGET_VAR}_CFLAGS}"
	eval "TARGET_LDFLAGS=\${${TARGET_VAR}_LDFLAGS}"
	OBJECTS="`src2obj $TARGET_SOURCES`"
	BUILD_ARTIFACTS="$BUILD_ARTIFACTS $OBJECTS"

	# TODO: emit target linking
	emit "`dynlib_fname \"$DYNAMIC_LIB\"`: subdirs $OBJECTS $EXTRA_DEPTS\n"
	emit "\t\"${LD}\" $LDFLAGS -shared -o `dynlib_fname \"$DYNAMIC_LIB\"` $OBJECTS\n"
	emit "\n"
	emit_target_deps $TARGET_SOURCES
done
emit "clean:\n"
for SUBDIR in $SUBDIRS; do
	emit "\tcd \"$SUBDIR\" && \$(MAKE) clean\n"
done
for ARTIFACT in $BUILD_ARTIFACTS; do
	emit "\trm -f $ARTIFACT\n"
done
for TARGET in $TARGETS; do
	emit "\trm -f $TARGET\n"
done
for STATIC_LIB in $STATIC_LIB_TARGETS; do
	emit "\trm -f `staticlib_fname $STATIC_LIB`\n"
done
for DYNAMIC_LIB in $DYNAMIC_LIB_TARGETS; do
	emit "\trm -f `dynlib_fname $DYNAMIC_LIB`\n"
done
emit "\n"
